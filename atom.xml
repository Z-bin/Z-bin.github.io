<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhoubin</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhoubin.wang/"/>
  <updated>2018-02-28T13:23:56.691Z</updated>
  <id>http://www.zhoubin.wang/</id>
  
  <author>
    <name>小子</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity-编辑器结构</title>
    <link href="http://www.zhoubin.wang/2018/02/27/Unity-%E7%BC%96%E8%BE%91%E5%99%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://www.zhoubin.wang/2018/02/27/Unity-编辑器结构/</id>
    <published>2018-02-27T14:36:31.000Z</published>
    <updated>2018-02-28T13:23:56.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文目的意在熟悉编辑器的结构，懂得各视图所起到的功能【有待填坑的地方】。<br>Unity版本：5.6.of03,Windows系统。<br>参考文献：《Unity3D游戏开发》-宣雨松著</p><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>打开Unity编辑器后再左上角“File” → “New Project” 然后可输入工程名称，即可创建一个新的工程。打开一个工程为“File” → “Open Project”,选择所要打开的工程即可。<br><code>Unity窗口</code><br><img src="http://p3x96gu8q.bkt.clouddn.com/Unity-Open.png" alt=""></p><h3 id="Project视图"><a href="#Project视图" class="headerlink" title="Project视图"></a>Project视图</h3><p>Project视图主要存放资源文件，包括游戏脚本、预设、材质、动画、自定义字体等，在Project视图左上角点击“Create”按钮，将出现一个下拉列表。<br><img src="http://p3x96gu8q.bkt.clouddn.com/Proejct%E8%A7%86%E5%9B%BE.png" alt=""></p><ul><li>Folder：文件夹，用于资源的分类。</li><li>C# Scrippt：C#脚本文件。</li><li>Javascript：Jasvascript脚本文件。</li><li>Prefab：预设，用于场景中游戏对象的克隆。</li><li>Render Texture：渲染贴图。</li><li>Material: 材质，用于为模型添加颜色与贴图。</li><li>Animation：游戏动画。</li><li>Physic Material：物理材质。</li><li>Shader：</li><li>Testing：</li><li>Scene：</li><li>Audio Mixer：</li><li>Lens Flare：</li><li>Lighmap Parameters：</li><li>Sprites：</li><li>Animator Controller：</li><li>Animator Override Controler：</li><li>Avatar Mask：</li><li>GUI Skin：<br>创建完资源后，将保存在工程根目录的“Assets”文件夹中，也可导入现有资源到Project视图中，可采用拖拽方式或者右击“Assets” → “Import Package”即可。</li></ul><h3 id="Hirarchy视图"><a href="#Hirarchy视图" class="headerlink" title="Hirarchy视图"></a>Hirarchy视图</h3><p>主要存放游戏场景中具体的游戏对象，如摄像机，平面贴图，3D贴图，光源，箱子等。<br><img src="http://p3x96gu8q.bkt.clouddn.com/Hierarchy%E8%A7%86%E5%9B%BE.png" alt=""></p><ul><li>3D Object：3D对象如立方体，球体，圆柱体等。</li><li>2D Object：2D对象。</li><li>Light：光源如点光源，定向光源等。</li><li>Audio：音频。</li><li>Video：视频。</li><li>UI：UI控件如平面滑动条等。</li></ul><h3 id="Inspector视图"><a href="#Inspector视图" class="headerlink" title="Inspector视图"></a>Inspector视图</h3><p>可以理解成为存放游戏对象、游戏资源、游戏设置以及展示描述信息的地方，无论你是选择一个游戏对象，还是控件时，Inspector将展示选择对象的信息，参数，修改Inspector视图的参数后可以在Game视图中看到修改后的效果。</p><h3 id="Scene视图"><a href="#Scene视图" class="headerlink" title="Scene视图"></a>Scene视图</h3><p>存放游戏中的模型资源。</p><h3 id="Game视图"><a href="#Game视图" class="headerlink" title="Game视图"></a>Game视图</h3><p>展示游戏效果的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文目的意在熟悉编辑器的结构，懂得各视图所起到的功能【有待填坑的地方】。&lt;br&gt;Unity版本：5.6.of03,Windows系统。&lt;br
      
    
    </summary>
    
      <category term="Unity" scheme="http://www.zhoubin.wang/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://www.zhoubin.wang/2018/02/21/%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.zhoubin.wang/2018/02/21/排序/</id>
    <published>2018-02-21T08:07:17.000Z</published>
    <updated>2018-02-26T09:07:09.208Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>算法(第四版)第二章排序部分的代码实现以及简单总结<br>所需要用到的<a href="https://github.com/Z-bin/Algorithms/blob/master/src/algs4/StdIn.java" target="_blank" rel="noopener">StdIn</a>和<a href="https://github.com/Z-bin/Algorithms/blob/master/src/algs4/StdOut.java" target="_blank" rel="noopener">StdOut</a>以及部分方法代码<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private static boolean less(Comparable v, Comparable w) //比较大小</span><br><span class="line">&#123;</span><br><span class="line">return v.compareTo(w) &lt; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void exch(Comparable[] a, int i, int j)  //交换元素</span><br><span class="line">&#123;</span><br><span class="line">Comparable t = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void show(Comparable[] a) </span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; a.length; i++) </span><br><span class="line">&#123;</span><br><span class="line">StdOut.print(a[i] + &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">StdOut.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static boolean isSorted(Comparable[] a) </span><br><span class="line">&#123;</span><br><span class="line">for (int i = 0; i &lt; a.length; i++) </span><br><span class="line">&#123;</span><br><span class="line">if (less(a[i], a[i - 1])) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) </span><br><span class="line">&#123;</span><br><span class="line">String[] a = StdIn.readAllStrings();</span><br><span class="line">sort(a);</span><br><span class="line">assert isSorted(a);</span><br><span class="line">show(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>首先，找到数组中最小的那个元素，其次，和数组的第一个元素交换位置。再次在剩下的元素中找到最小的元素，与数组第二个元素交换位置，以此类推。交换的总次数为N，时间效率取决于比较的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a) </span><br><span class="line">&#123;</span><br><span class="line">int N = a.length;</span><br><span class="line">for (int i = 0; i &lt; N; i++) </span><br><span class="line">&#123;</span><br><span class="line">int min = i;//最小元素索引</span><br><span class="line">for (int j = i + 1; j &lt; N; j++) </span><br><span class="line">&#123;</span><br><span class="line">if (less(a[j], a[min])) </span><br><span class="line">&#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">exch(a, i, min);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序正如我们整理桥牌一样，将每一张牌插入到其他已经有序的牌中的适当位置，所需时间取决于输入中元素的顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a)</span><br><span class="line">&#123;</span><br><span class="line">int N = a.length;</span><br><span class="line">for(int i = 1; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">//将a[i]插入到a[i-1]、a[i-2]、a[i-3]...之中</span><br><span class="line">for(int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--)</span><br><span class="line">exch(a, j, j-1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>基于插入排序的一种改进，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有有序的数组排序。思想是使数组中任意间隔为h的元素都是有序的。</p><p><code>例如h为4时，间隔为4的元素都是有序的</code><br><img src="http://p3x96gu8q.bkt.clouddn.com/shellSort.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a)</span><br><span class="line">&#123;</span><br><span class="line">int N = a.length;</span><br><span class="line">int h = 1;</span><br><span class="line">while(h &lt; N/3)</span><br><span class="line">h = h*3 + 1;</span><br><span class="line">while(h &gt;= 1)</span><br><span class="line">&#123;</span><br><span class="line">//将数组变为h有序</span><br><span class="line">for(int i = h; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">//将a[i]插入到a[i-h]、a[i-2*h]、a[i-3*h]...之中</span><br><span class="line">for(int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h)</span><br><span class="line">exch(a, j, j-h);</span><br><span class="line">&#125;</span><br><span class="line">h /=3;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>以上算法都基于归并这个操作，即将两个有序数组归并成一个更大的有序数组。要将一个数组排序，可以先（递归的）将它分成两半进行排序，然后将结果归并起来。数组长度为N，所需时间和NlogN成正比，如需额外空间和N成正比。</p><p><code>示意图</code><br><img src="http://p3x96gu8q.bkt.clouddn.com/mergeSort.png" alt=""><br>归并操作需要一个额外的数组aux,方法是将所有元素复制到aux[]中，然后归并到a[]中。左半边用尽（取右半边元素），右半边用尽（取左半边元素），右半边当前元素小于左半边当前元素(取右半边元素)，反之取左半边元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void merge(Comparable[] a, int lo, int mid, int hi)</span><br><span class="line">&#123;</span><br><span class="line">int i = lo, j = mid+1;</span><br><span class="line"></span><br><span class="line">for(int k = lo; k &lt;= hi; k++)</span><br><span class="line">aux[k] = a[k];</span><br><span class="line"></span><br><span class="line">for(int k = lo; k &lt;= hi; k++)</span><br><span class="line">&#123;</span><br><span class="line">if(i &gt; mid)</span><br><span class="line">a[k] = aux[j++];</span><br><span class="line">else if(j &gt; hi)</span><br><span class="line">a[k] = aux[i++];</span><br><span class="line">else if(less(aux[j], aux[i]))</span><br><span class="line">a[k] = aux[j++];</span><br><span class="line">else </span><br><span class="line">a[k] = aux[i++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>自顶向下版本</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a)</span><br><span class="line">&#123;</span><br><span class="line">aux =new Comparable[a.length];//为辅助数组分配空间</span><br><span class="line">sort(a, 0, a.length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void sort(Comparable[] a, int lo, int hi)</span><br><span class="line">&#123;</span><br><span class="line">if(hi &lt;= lo)</span><br><span class="line">return;</span><br><span class="line">int mid = lo + ((hi - lo) &gt;&gt; 1);</span><br><span class="line">sort(a, lo ,mid);//将左半边排序</span><br><span class="line">sort(a, mid+1, hi);//将右半边排序</span><br><span class="line">merge(a, lo, mid, hi);//归并结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>自底向上版本</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] a)</span><br><span class="line">&#123;</span><br><span class="line">int N = a.length;</span><br><span class="line">aux = new Comparable[N];</span><br><span class="line">for(int sz = 1; sz &lt; N; sz +=sz)//sz:子数组大小</span><br><span class="line">for(int lo = 0; lo &lt; N - sz; lo +=sz+sz)//lo:子数组索引</span><br><span class="line">merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>一种分治的排序算法，归并排序是将一个数组分成两个字数组进行排序，并将有序的子数组归并以将整个数组排序，而快速排序是当两个子数组有序时整个数组也就自然有序了。前者递归调用发生在处理整个数组之前，后者相反。<br><code>示意图</code><br><img src="http://p3x96gu8q.bkt.clouddn.com/quickSort.png" alt=""><br>方法的关键在于切分，这个过程使得数组满足以下三个条件：<br>&emsp;&emsp;1、对于某个j，a[j]已经排定；<br>&emsp;&emsp;2、a[lo]到a[j-1]的元素都不大于a[j]；<br>&emsp;&emsp;3、a[j+1]到a[hi]的元素都不小于a[j]；<br>一般策略是随意的取a[lo]作为切分元素，即那个将会被排定的元素，然后我们从数组左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。交换它们的位置，如此继续，保证左指针i的左侧元素都不大于切分元素，右指针j的右侧元素都不小于切分元素。当两指针相遇时，将切分元素a[lo]和左子数组最右侧元素a[j]交换返回j即可。<br><code>示意图</code><br><img src="http://p3x96gu8q.bkt.clouddn.com/quickSort1.png" alt=""><br><code>代码</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static int partition(Comparable[] a, int lo, int hi)</span><br><span class="line">&#123;</span><br><span class="line">int i = lo, j = hi+1;//左右指针</span><br><span class="line">Comparable v = a[lo];//切分元素</span><br><span class="line">while(true)</span><br><span class="line">&#123;</span><br><span class="line">//扫描左右，检查扫描是否结束并交换元素</span><br><span class="line">while(less(a[++i], v))</span><br><span class="line">if(i == hi)</span><br><span class="line">break;</span><br><span class="line">while(less(v, a[--j]))</span><br><span class="line">if(j == lo)</span><br><span class="line">break;</span><br><span class="line">if(i &gt;= j)</span><br><span class="line">break;</span><br><span class="line">exch(a, i, j);</span><br><span class="line">&#125;</span><br><span class="line">exch(a, lo, j);//将v = a[j]放入正确位置</span><br><span class="line">return j;//a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi] 达成</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(Comparable[] a)</span><br><span class="line">&#123;</span><br><span class="line">sort(a, 0, a.length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(Comparable[] a, int lo, int hi)</span><br><span class="line">&#123;</span><br><span class="line">if(hi &lt;= lo)</span><br><span class="line">return;</span><br><span class="line">int j = partition(a, lo, hi);//数组切分</span><br><span class="line">sort(a, lo, j-1);//将左半部分a[lo..j-1]排序</span><br><span class="line">sort(a, j+1, hi);//将右半部分a[j+1..hi]排序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三向切分的快速排序"><a href="#三向切分的快速排序" class="headerlink" title="三向切分的快速排序"></a>三向切分的快速排序</h3><p>对于存在大量重复元素的数组，这种方法比快速排律效率高得多。维护一个指针lt使得a[lo..lt-1]中的元素都小于v,一个指针gt使得a[gt-1..hi]中的元素都大于v，一个指针i使得a[lt..i-1]中的元素都等于v，a[i..gt]中元素还未确定。一开始，i和lo相等。<br>&emsp;&emsp;1、a[i]小于v，将a[lt]和a[i]交换,将lt和i加一；<br>&emsp;&emsp;2、a[i]大于v，将a[gt]和a[i]交换,将gt减一；<br>&emsp;&emsp;3、a[i]等于v，将i加一；<br><code>示意图</code><br><img src="http://p3x96gu8q.bkt.clouddn.com/%E4%B8%89%E5%90%91%E5%88%87%E5%88%86.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi)</span><br><span class="line">&#123;</span><br><span class="line">if(hi &lt;= lo)</span><br><span class="line">return;</span><br><span class="line">int lt = lo, i = lo + 1, gt = hi;</span><br><span class="line">Comparable v = a[lo];</span><br><span class="line">while(i &lt;= gt)</span><br><span class="line">&#123;</span><br><span class="line">int cmp = a[i].compareTo(v);</span><br><span class="line">if(cmp &lt; 0)</span><br><span class="line">exch(a, lt++, i++);</span><br><span class="line">else if(cmp &gt; 0)</span><br><span class="line">exch(a, i, gt--);</span><br><span class="line">else </span><br><span class="line">i++;</span><br><span class="line">&#125;//现在a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]</span><br><span class="line">sort(a, lo, lt-1);</span><br><span class="line">sort(a, gt+1, hi);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;算法(第四版)第二章排序部分的代码实现以及简单总结&lt;br&gt;所需要用到的&lt;a href=&quot;https://github.com/Z-bin/Algorithms/blob/master/src/algs4/StdIn.java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;StdIn&lt;/a&gt;和&lt;a href=&quot;https://github.com/Z-bin/Algorithms/blob/master/src/algs4/StdOut.java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;StdOut&lt;/a&gt;以及部分方法代码&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.zhoubin.wang/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法(第四版)" scheme="http://www.zhoubin.wang/tags/%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>2017-2018</title>
    <link href="http://www.zhoubin.wang/2018/02/17/2017-2018/"/>
    <id>http://www.zhoubin.wang/2018/02/17/2017-2018/</id>
    <published>2018-02-17T14:54:51.000Z</published>
    <updated>2018-02-21T02:26:32.819Z</updated>
    
    <content type="html"><![CDATA[<p>在放寒假几天后也终于将自己的第一个独立博客搭建完成了，前一段时间一直在CSDN上写自己的技术博客，现在算是换一个地方继续写，一是记录自身技术与生活的成长，二是用这种方式激励自己。今天已经是2018的第二天了，走完亲戚拜完年有些累，闲下来写下来作为自己独立博客的第一篇以及对去年一些总结和对新年的期待。<br><a id="more"></a><br>2017年感觉自己的技术成长依旧很缓慢，虽然与环境有关系，但是最主要的原因还是在于自身问题。暑假依旧留校参加省程序设计大赛，很遗憾的是与大一时的结果一样打铁与奖牌无缘，之后写的反思中发现自己存在的几大问题，①对自己没有足够的信心认为自己不如别人，②学习效率及其低下，在训练过程中注意力不集中易被外物吸引或影响，③存在一种畏难心理不愿去深究问题的本质。这两次的失败应该为我以后敲响一个警钟，时时牢记不可再犯。作为一个只能称为伪ACMer的我还没有在这门学科当中找到自己喜欢的方向，大二下时选了数字媒体，自己慢慢开始摸索好好学，“吾生也有涯，而知也无涯。以有涯随无涯，殆已”，以后自己不能够乱点技能树了，瞎点也最好点亮被动技能，因为剩下来的大学时光已经不多了。暑假亲人逝世，要更加珍惜在自己身边的人 –“落花风雨更伤春，不如怜取眼前人”。</p><p>2018年是新的一年，一开学就是大三下了，自己做了一个重要的决定 –“考研”，技术成长的缓慢无法支撑我对于offer的野心，希望让自己跨上一个更高层次平台来再好好成长几年汲取知识技术寻求一份好的工作，实验室几个考研的学长学姐结果均不错，愿自己也可以向他们一样优秀。既然自己搭建了这份博客就不能够使他荒废，做出了考研的决定就意味着有许多时间要分配于之上，但是以后要尽量保证3-4天有一篇博客的产出来写下自己对专业知识学习进度，如逆水行舟，不进则退啊！</p><p>新的一年多多读书，多多去外面走走，少玩手机，期望有一个美好的未来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在放寒假几天后也终于将自己的第一个独立博客搭建完成了，前一段时间一直在CSDN上写自己的技术博客，现在算是换一个地方继续写，一是记录自身技术与生活的成长，二是用这种方式激励自己。今天已经是2018的第二天了，走完亲戚拜完年有些累，闲下来写下来作为自己独立博客的第一篇以及对去年一些总结和对新年的期待。&lt;br&gt;
    
    </summary>
    
      <category term="杂文" scheme="http://www.zhoubin.wang/categories/%E6%9D%82%E6%96%87/"/>
    
    
  </entry>
  
</feed>
